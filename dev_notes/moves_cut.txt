// STATUSMOVES that change the opponent's statusAilment

class Toxic extends StatusMove with NonVolatileStatChange {
  override val index = 92
  override val type1 = Poison
  override val maxPP = 10
  val chancePSN = 1.0
  override val accuracy = 0.85

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: Toxic is a mess and almost surely requires a battle data structure
  }
}


/* SUPER WEIRD STATUS MOVES */
class MirrorMove extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Get the last move that $defender used during his current stay in battle;
    val lastMove : Option[Move] = pb.moveManager.getLastMove(defender)

    // $attacker should use lastMove against $defender
    lastMove match {
      case Some(m) => m.use(attacker, defender, pb)
      case None    => {}
    }
  }

  /*
   * MirrorMove would get the updateLastMoveIndex wrong, since the order would be:
   * MirrorMove.startUsingMove()
   * MirrorMove.moveSpecificStuff()   => uses Move m
   *   m.startUsingMove()
   *   m.moveSpecificStuff()
   *   m.finishUsingMove()            => sets lastMoveUsed to the correct value
   * Move.finishUsingMove()     => sets it back to incorrect value
   * So just don't update lastMoveUsed after calling MirrorMove!
   */
  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    currentPP -= 1
  }
}

class Haze extends StatusMove {
  override val index = 114
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) {
    // http://bulbapedia.bulbagarden.net/wiki/Haze_(move)
    // reset the stat levels of both active Pokemon to 0
    pb.statManager.resetAll(attacker)
    pb.statManager.resetAll(defender)

    // TODO: fill in all the crazy stuff that Haze does
    // remove the stat reductions due to BRN/PAR

    // negate Focus Energy for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate Light Screen for both active Pokemon

    // negate Mist for both active Pokemon

    // negate Reflect for both active Pokemon

    // negate confusion for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate any major status ailments for THE ENEMY

    // Superweird thing that happens if an opponent is trying to use Hyper Beam, then gets frozen, and then Haze unfreezes him
  }
}

class Mist extends StatusMove {
  override val index = 54
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Mist_(move)
    // Mist protects the user from stat mods inflicted by the opponent until it switches out
    // TODO: flip the Mist switch for attacker in the Battle's Mist data structure
  }
}

class Conversion extends StatusMove {
  override val index = 160
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Conversion changes the types of the attacker to be those of the defender
    // Porygon is the only Pokemon in the game that can learn this move
    assert(attacker.index == 137, "someone other than Porygon tried to use Conversion!")
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2
  }
}

class Metronome extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  private def getValidIndex() : Int = {
      val potentialIndex = Utils.intBetween(1, 165 + 1)
      if (potentialIndex != index && potentialIndex != 165) potentialIndex
      else getValidIndex()
  }

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // randomly selects a move (other than itself and Struggle) and then executes the attack with normal priority
    val randomIndex = getValidIndex()
    val moveToUse = MoveMaker.makeMove(randomIndex)
    // moveToUse.priority = 0    // TODO: make this work!
    moveToUse.use(attacker, defender, pb)
  }

  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // The random move used is logged as the most recent move used, so don't log a la MirrorMove
    currentPP -= 1
  }
}

class Mimic extends StatusMove {
  override val index = 102
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: figure out what Mimic actually does in Gen 1, then make it happen
  }
}

class Recovery extends StatusMove {
  override val index = 105
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.recoverBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Rest extends StatusMove {
  override val index = 156
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Rest_(move)
    // On the turn that the Pokemon uses it: switch to SLP, regain all HP
    // Next turn: Pokemon is asleep, can Switch; choosing Fight causes it to tell you that Pokemon is asleep
    // Next turn: wake up at beginning of turn, can use an action
    // TODO: implement this in some data structure that tracks SLP
  }
}

class SoftBoiled extends StatusMove {
  override val index = 135
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Same as recovery!
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.softboiledBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Transform extends StatusMove {
  override val index = 144
  override val maxPP = 10
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Transform_(move)
    // http://www.smogon.com/rb/moves/Transform

    // Change the user's current type to that of the target
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2

    // Change the user's current stats to that of the target
    // TODO: which stats, exactly, are duplicated? EV? IV? attack/defense?

    // Change the user's current stat modifications to that of the target
    pb.statManager.setAttackStage(attacker, pb.statManager.attackStages(defender))
    pb.statManager.setDefenseStage(attacker, pb.statManager.defenseStages(defender))
    pb.statManager.setSpecialStage(attacker, pb.statManager.specialStages(defender))
    pb.statManager.setSpeedStage(attacker, pb.statManager.speedStages(defender))
    pb.statManager.setAccuracyStage(attacker, pb.statManager.accuracyStages(defender))
    pb.statManager.setEvasionStage(attacker, pb.statManager.evasionStages(defender))

    // Change the user's current moves to those of the target
    val move1 = defender.move1 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move2 = defender.move2 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move3 = defender.move3 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move4 = defender.move4 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
  }
}
