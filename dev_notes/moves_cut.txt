// SPECIAL, FUNCTION OF LEVEL
class NightShade extends SpecialMove {
  override val index = 101
  override val type1 = Ghost
  override val power = 0
  override val maxPP = 15
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      defender.takeDamage(attacker.level)
    }
  }
}

class Psywave extends SpecialMove {
  override val index = 149
  override val type1 = Psychic
  override val power = 0
  override val maxPP = 15
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val damageDealt = ((Random.nextDouble + 0.5) * attacker.level).toInt
      defender.takeDamage(damageDealt)
    }
  }
}


// SPECIAL, SINGLESTRIKE WITH POTENTIAL WEIRD STUFF
abstract class SpecialSingleStrike extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
    }
  }
}

class TriAttack extends SpecialSingleStrike {
  // TODO: Why is this listed as a Special move, given that it's type Normal?
  override val index = 161
  override val type1 = Normal
  override val power = 80
  override val maxPP = 10
}

class HydroPump extends SpecialSingleStrike {
  override val index = 56
  override val type1 = Water
  override val power = 120   // down to 110 in Gen IV
  override val maxPP = 5
  override val accuracy = 0.8
}

class Surf extends SpecialSingleStrike {
  override val index = 57
  override val type1 = Water
  override val power = 95   // down to 90 in Gen IV
  override val maxPP = 15
}

class WaterGun extends SpecialSingleStrike {
  override val index = 55
  override val type1 = Water
  override val power = 40
  override val maxPP = 25
}

class RazorLeaf extends SpecialSingleStrike {
  override val index = 75
  override val type1 = Grass
  override val power = 55
  override val maxPP = 25
  override val accuracy = 0.95
  override val critHitRate = HIGH
}


// TODO: SWIFT: IGNORE MODS TO ACCURACY AND EVASION, HIT FLY/DIG POKEMON


// SPECIAL: TRANSFER HP
abstract class SpecialTransferHP extends SpecialMove {
  // TODO: If MOVE breaks a substitute, no HP will be restored to the user.
  val transferProportion = 0.5
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
      damageDealt match {
        case 1 => attacker.gainHP(1)
        case _ => attacker.gainHP((damageDealt * transferProportion).toInt)
      }
    }
  }
}

class Absorb extends SpecialTransferHP {
  override val index = 71
  override val type1 = Grass
  override val power = 20
  override val maxPP = 20  // 25 in later gens
}

class MegaDrain extends SpecialTransferHP {
  override val index = 72
  override val type1 = Grass
  override val power = 40
  override val maxPP = 10  // 15 in later gens
}

class DreamEater extends SpecialMove {
  // TODO: If DreamEater breaks a substitute, no HP will be restored to the user.
  override val index = 138
  override val type1 = Psychic
  override val power = 40
  override val maxPP = 10  // 15 in later gens

  val transferProportion = 0.5

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    defender.statusAilment match {
      case Some(_ : SLP) => {
        if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
          val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
          defender.takeDamage(damageDealt)
          damageDealt match {
            case 1 => attacker.gainHP(1)
            case _ => attacker.gainHP((damageDealt * transferProportion).toInt)
          }
        }
      }
      case _ => {}
    }
  }
}


// SPECIAL, DAMAGE + POTENTIAL STAT CHANGE
abstract class SpecialDamageStat extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: fill in!
  }
}


// SPECIAL, DAMAGE + POTENTIAL STATUS CHANGE
abstract class SpecialDamageStatus extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: fill in!
  }
}


abstract class Thunderbolt extends SpecialDamageStatus
abstract class ThunderShock extends SpecialDamageStatus
abstract class Ember extends SpecialDamageStatus


/* STATUS MOVES */

// STATUSMOVES that change the opponent's stats
// TODO: Make sure that the opponent's stats can actually be changed!
abstract class StatusChangeDefenderStats extends StatusMove {
  val statToChange : BattleStat.Value
  val amount : Int
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (pb.statManager.canChangeDefenderStats(attacker, defender, pb)) {
      statToChange match {
        case ATTACK   => pb.statManager.changeAttackStage(defender, amount)
        case DEFENSE  => pb.statManager.changeDefenseStage(defender, amount)
        case SPEED    => pb.statManager.changeSpeedStage(defender, amount)
        case SPECIAL  => pb.statManager.changeSpecialStage(defender, amount)
        case ACCURACY => pb.statManager.changeAccuracyStage(defender, amount)
        case EVASION  => pb.statManager.changeEvasionStage(defender, amount)
      }
    }
  }
}

class StringShot extends StatusChangeDefenderStats {
  override val index = 81
  override val accuracy = .95          // in [0.0, 1.0]
  override val type1 = Bug
  override val maxPP = 40
  override val statToChange = SPEED
  override val amount = -1
}

class SandAttack extends StatusChangeDefenderStats {
  override val index = 28
  override val type1 = Normal  // changed in later Gens
  override val maxPP = 15
  override val statToChange = ACCURACY
  override val amount = -1
}

class Flash extends StatusChangeDefenderStats {
  override val index = 148
  override val type1 = Normal
  override val maxPP = 20
  override val accuracy = 0.7
  override val statToChange = ACCURACY
  override val amount = -1
}

class SmokeScreen extends StatusChangeDefenderStats {
  override val index = 108
  override val type1 = Normal
  override val maxPP = 20
  override val statToChange = ACCURACY
  override val amount = -1
}

class Kinesis extends StatusChangeDefenderStats {
  override val index = 134
  override val type1 = Psychic
  override val maxPP = 15
  override val accuracy = 0.8
  override val statToChange = ACCURACY
  override val amount = -1
}

class Growl extends StatusChangeDefenderStats {
  override val index = 45
  override val type1 = Normal
  override val maxPP = 40
  override val statToChange = ATTACK
  override val amount = -1
}

class Leer extends StatusChangeDefenderStats {
  override val index = 43
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = -1
}

class TailWhip extends StatusChangeDefenderStats {
  override val index = 39
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = -1
}

class Screech extends StatusChangeDefenderStats {
  override val index = 103
  override val type1 = Normal
  override val maxPP = 40
  override val accuracy = 0.85
  override val statToChange = DEFENSE
  override val amount = -2
}


// STATUSMOVES that change the opponent's statusAilment
abstract class StatusCauseStatusAilment extends StatusMove {
  val statusAilmentToCause : StatusAilment
  val chanceOfCausingAilment : Double

  def statusAilmentCaused : Boolean = Random.nextDouble < chanceOfCausingAilment

  // TODO: Figure out if there are times when a Pokemon is immune to StatusAilment changes, and incorporate them
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb) && statusAilmentCaused) {
      statusAilmentToCause match {
        case (_ : NonVolatileStatusAilment) => pb.statusManager.tryToChangeStatusAilment(defender, statusAilmentToCause)
        case (_ : CONFUSION) => pb.statusManager.tryToCauseConfusion(defender)
        case (_ : FLINCH) => pb.statusManager.causeToFlinch(defender)
        case (_ : PARTIALLYTRAPPED) => { pb.statusManager.tryToPartiallyTrap(defender) }
        case (_ : SEEDED) => pb.statusManager.tryToSeed(defender)
      }
    }
  }
}

class ThunderWave extends StatusCauseStatusAilment {
  override val index = 86
  override val type1 = Electric
  override val maxPP = 20
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
}

class StunSpore extends StatusCauseStatusAilment {
  override val index = 78
  override val type1 = Grass
  override val maxPP = 30
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75
}

class Glare extends StatusCauseStatusAilment {
  override val index = 137
  override val type1 = Normal
  override val maxPP = 30
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75  // increased in later generations
}

class ConfuseRay extends StatusCauseStatusAilment {
  override val index = 109
  override val type1 = Ghost
  override val maxPP = 10
  val statusAilmentToCause = new CONFUSION
  val chanceOfCausingAilment = 1.0
  // TODO: ConfuseRay will fail if the target has a substitute
}

class Supersonic extends StatusCauseStatusAilment {
  override val index = 48
  override val type1 = Normal
  override val maxPP = 20
  val statusAilmentToCause = new CONFUSION
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.55
  // TODO: Supersonic will fail if the target has a substitute
}

class SleepPowder extends StatusCauseStatusAilment {
  override val index = 79
  override val type1 = Grass
  override val maxPP = 15
  val statusAilmentToCause = new SLP
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75
  // TODO: SleepPowder will fail if the target has a substitute
}

class Hypnosis extends StatusCauseStatusAilment {
  override val index = 95
  override val type1 = Psychic
  override val maxPP = 15
  val statusAilmentToCause = new SLP
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.60
}

class PoisonGas extends StatusCauseStatusAilment {
  override val index = 139
  override val type1 = Poison
  override val maxPP = 40
  val statusAilmentToCause = new PSN
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.55
}

class Toxic extends StatusMove {
  override val index = 92
  override val type1 = Poison
  override val maxPP = 10
  val chancePSN = 1.0
  override val accuracy = 0.85


  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: Toxic is a mess and almost surely requires a battle data structure
  }
}


/* SUPER WEIRD STATUS MOVES */
class MirrorMove extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Get the last move that $defender used during his current stay in battle;
    val lastMove : Option[Move] = pb.moveManager.getLastMove(defender)

    // $attacker should use lastMove against $defender
    lastMove match {
      case Some(m) => m.use(attacker, defender, pb)
      case None    => {}
    }
  }

  /* MirrorMove would get the updateLastMoveIndex wrong, since the order would be:
   * MirrorMove.startUsingMove()
   * MirrorMove.moveSpecificStuff()   => uses Move m
   *   m.startUsingMove()
   *   m.moveSpecificStuff()
   *   m.finishUsingMove()            => sets lastMoveUsed to the correct value
   * Move.finishUsingMove()     => sets it back to incorrect value
   * So just don't update lastMoveUsed after calling MirrorMove!
   */
  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    currentPP -= 1
  }
}

class Haze extends StatusMove {
  override val index = 114
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) {
    // http://bulbapedia.bulbagarden.net/wiki/Haze_(move)
    // reset the stat levels of both active Pokemon to 0
    pb.statManager.resetAll(attacker)
    pb.statManager.resetAll(defender)

    // TODO: fill in all the crazy stuff that Haze does
    // remove the stat reductions due to BRN/PAR

    // negate Focus Energy for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate Light Screen for both active Pokemon

    // negate Mist for both active Pokemon

    // negate Reflect for both active Pokemon

    // negate confusion for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate any major status ailments for THE ENEMY

    // Superweird thing that happens if an opponent is trying to use Hyper Beam, then gets frozen, and then Haze unfreezes him
  }
}

class Mist extends StatusMove {
  override val index = 54
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Mist_(move)
    // Mist protects the user from stat mods inflicted by the opponent until it switches out
    // TODO: flip the Mist switch for attacker in the Battle's Mist data structure
  }
}

class Conversion extends StatusMove {
  override val index = 160
  override val type1 = Normal
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Conversion changes the types of the attacker to be those of the defender
    // Porygon is the only Pokemon in the game that can learn this move
    assert(attacker.index == 137, "someone other than Porygon tried to use Conversion!")
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2
  }
}

class Metronome extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  private def getValidIndex() : Int = {
      val potentialIndex = Utils.intBetween(1, 165 + 1)
      if (potentialIndex != index && potentialIndex != 165) potentialIndex
      else getValidIndex()
  }

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // randomly selects a move (other than itself and Struggle) and then executes the attack with normal priority
    val randomIndex = getValidIndex()
    val moveToUse = MoveMaker.makeMove(randomIndex)
    // moveToUse.priority = 0    // TODO: make this work!
    moveToUse.use(attacker, defender, pb)
  }

  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // The random move used is logged as the most recent move used, so don't log a la MirrorMove
    currentPP -= 1
  }
}

class Mimic extends StatusMove {
  override val index = 102
  override val type1 = Normal
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: figure out what Mimic actually does in Gen 1, then make it happen
  }
}

class Recovery extends StatusMove {
  override val index = 105
  override val type1 = Normal
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.recoverBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Rest extends StatusMove {
  override val index = 156
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Rest_(move)
    // On the turn that the Pokemon uses it: switch to SLP, regain all HP
    // Next turn: Pokemon is asleep, can Switch; choosing Fight causes it to tell you that Pokemon is asleep
    // Next turn: wake up at beginning of turn, can use an action
    // TODO: implement this in some data structure that tracks SLP
  }
}

class SoftBoiled extends StatusMove {
  override val index = 135
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Same as recovery!
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.softboiledBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Roar extends StatusMove {
  override val index = 46
  override val type1 = Normal
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Whirlwind extends StatusMove {
  override val index = 18
  override val type1 = Normal
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Teleport extends StatusMove {
  override val index = 100
  override val type1 = Psychic
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Splash extends StatusMove {
  override val index = 150
  override val type1 = Normal
  override val maxPP = 40
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against anyone
  }
}

class Transform extends StatusMove {
  override val index = 144
  override val type1 = Normal
  override val maxPP = 10
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Transform_(move)
    // http://www.smogon.com/rb/moves/Transform

    // Change the user's current type to that of the target
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2

    // Change the user's current stats to that of the target
    // TODO: which stats, exactly, are duplicated? EV? IV? attack/defense?

    // Change the user's current stat modifications to that of the target
    pb.statManager.setAttackStage(attacker, pb.statManager.attackStages(defender))
    pb.statManager.setDefenseStage(attacker, pb.statManager.defenseStages(defender))
    pb.statManager.setSpecialStage(attacker, pb.statManager.specialStages(defender))
    pb.statManager.setSpeedStage(attacker, pb.statManager.speedStages(defender))
    pb.statManager.setAccuracyStage(attacker, pb.statManager.accuracyStages(defender))
    pb.statManager.setEvasionStage(attacker, pb.statManager.evasionStages(defender))

    // Change the user's current moves to those of the target
    val move1 = defender.move1 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move2 = defender.move2 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move3 = defender.move3 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move4 = defender.move4 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
  }
}
