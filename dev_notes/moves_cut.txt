
/* PHYSICAL MOVES */
// PHYSICAL, HP TRANSFER
class LeechLife extends PhysicalMove {
  override val index = 141
  override val type1 = Bug
  override val power = 20
  override val maxPP = 15

  // TODO: if LL breaks a substitute, no HP is restored
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
      damageDealt match {
        case 1 => attacker.gainHP(1)
        case _ => attacker.gainHP(damageDealt / 2)
      }
    }
  }
}

// PHYSICAL, SINGLE-STRIKE DAMAGE ONLY
class DrillPeck extends PhysicalMove with SingleStrike {
  override val index = 65
  override val type1 = Flying
  override val power = 80
  override val maxPP = 20
}

class Peck extends PhysicalMove with SingleStrike {
  override val index = 64
  override val type1 = Flying
  override val power = 35
  override val maxPP = 35
}

class WingAttack extends PhysicalMove with SingleStrike {
  override val index = 17
  override val type1 = Flying
  override val power = 35  // increased in later generations, weak in this one
  override val maxPP = 35
}

class Cut extends PhysicalMove with SingleStrike {
  override val index = 15
  override val type1 = Normal
  override val power = 50  // power and maxPP increased in later generations
  override val maxPP = 30
  override val accuracy = 0.95
}

class Earthquake extends PhysicalMove with SingleStrike {
  override val index = 89
  override val type1 = Ground
  override val power = 100
  override val maxPP = 10
}

class DizzyPunch extends PhysicalMove with SingleStrike {
  override val index = 146
  override val type1 = Normal
  override val power = 70
  override val maxPP = 10
}

class EggBomb extends PhysicalMove with SingleStrike {
  override val index = 121
  override val type1 = Normal
  override val power = 100
  override val maxPP = 10
  override val accuracy = 0.75
}

class HornAttack extends PhysicalMove with SingleStrike {
  override val index = 30
  override val type1 = Normal
  override val power = 65
  override val maxPP = 25
}

class MegaKick extends PhysicalMove with SingleStrike {
  override val index = 25
  override val type1 = Normal
  override val power = 120
  override val maxPP = 5
  override val accuracy = 0.75
}

class MegaPunch extends PhysicalMove with SingleStrike {
  override val index = 5
  override val type1 = Normal
  override val power = 80
  override val maxPP = 20
  override val accuracy = 0.85
}

class PayDay extends PhysicalMove with SingleStrike {
  override val index = 6
  override val type1 = Normal
  override val power = 40
  override val maxPP = 20
}

class Scratch extends PhysicalMove with SingleStrike {
  override val index = 10
  override val type1 = Normal
  override val power = 40
  override val maxPP = 35
}

class Slam extends PhysicalMove with SingleStrike {
  override val index = 21
  override val type1 = Normal
  override val power = 80
  override val maxPP = 20
  override val accuracy = 0.75
}

class Strength extends PhysicalMove with SingleStrike {
  override val index = 70
  override val type1 = Normal
  override val power = 80
  override val maxPP = 15
}

class ViceGrip extends PhysicalMove with SingleStrike {
  override val index = 11
  override val type1 = Normal
  override val power = 55
  override val maxPP = 30
}

class RockSlide extends PhysicalMove with SingleStrike {
  override val index = 157
  override val type1 = Rock
  override val power = 75
  override val maxPP = 10
  override val accuracy = 0.9
}

class RockThrow extends PhysicalMove with SingleStrike {
  override val index = 88
  override val type1 = Rock
  override val power = 50
  override val maxPP = 15
  override val accuracy = 0.65  // much higher in later generations
}


// PHYSICAL, SINGLE STRIKE + POTENTIAL STATUS CHANGE
abstract class PhysicalSingleStrikeStatusChange extends PhysicalMove {
  val statusAilmentToCause   : StatusAilment
  val chanceOfCausingAilment : Double

  def statusAilmentCaused : Boolean = Random.nextDouble < chanceOfCausingAilment

  // TODO: Figure out if there are times when a Pokemon is immune to StatusAilment changes, and incorporate them
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
      if (statusAilmentCaused) statusAilmentToCause match {
        case (_ : NonVolatileStatusAilment) => pb.statusManager.tryToChangeStatusAilment(defender, statusAilmentToCause)
        case (_ : CONFUSION) => pb.statusManager.tryToCauseConfusion(defender)
        case (_ : FLINCH) => pb.statusManager.causeToFlinch(defender)
        case (_ : PARTIALLYTRAPPED) => { pb.statusManager.tryToPartiallyTrap(defender) }
        case (_ : SEEDED) => pb.statusManager.tryToSeed(defender)
      }
    }
  }
}

class Bite extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 44
  override val type1 = Normal
  override val power = 60
  override val maxPP = 25
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.10
}

class BoneClub extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 125
  override val type1 = Ground
  override val power = 65
  override val maxPP = 20
  override val accuracy = 0.85
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.10
  // TODO: Bone Club cannot cause a target with a substitute to flinch.
}

class HyperFang extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 158
  override val type1 = Normal
  override val power = 80
  override val maxPP = 15
  override val accuracy = 0.9
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.10
}

class LowKick extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 67
  override val type1 = Fighting
  override val power = 50
  override val maxPP = 20
  override val accuracy = 0.9
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.30
}

class Headbutt extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 29
  override val type1 = Normal
  override val power = 70
  override val maxPP = 15
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.30
}

class Stomp extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 23
  override val type1 = Normal
  override val power = 65
  override val maxPP = 20
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.30
  // TODO: Stomp cannot make a target with a substitute flinch.
}

class RollingKick extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 27
  override val type1 = Fighting
  override val power = 60
  override val maxPP = 15
  override val accuracy = 0.85
  override val statusAilmentToCause = new FLINCH
  override val chanceOfCausingAilment = 0.30
  // TODO: Rolling Kick cannot make a target with a substitute flinch.
}

class ThunderPunch extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 9
  override val type1 = Electric
  override val power = 75
  override val maxPP = 15
  override val statusAilmentToCause = new PAR
  override val chanceOfCausingAilment = 0.10
}

class IcePunch extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 8
  override val type1 = Ice
  override val power = 75
  override val maxPP = 15
  override val statusAilmentToCause = new FRZ
  override val chanceOfCausingAilment = 0.10
}

class FirePunch extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 7
  override val type1 = Fire
  override val power = 75
  override val maxPP = 15
  override val statusAilmentToCause = new BRN
  override val chanceOfCausingAilment = 0.10
}

class Lick extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 122
  override val type1 = Ghost
  override val power = 20
  override val maxPP = 30
  override val statusAilmentToCause = new PAR
  override val chanceOfCausingAilment = 0.3
}

class BodySlam extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 34
  override val type1 = Normal
  override val power = 85
  override val maxPP = 15
  override val statusAilmentToCause = new PAR
  override val chanceOfCausingAilment = 0.3
}

class PoisonSting extends PhysicalMove with SingleStrikeStatusChange {
  override val index = 40
  override val type1 = Poison
  override val power = 15
  override val maxPP = 35
  override val statusAilmentToCause = new PSN
  override val chanceOfCausingAilment = 0.3
}


// PHYSICAL, SINGLE-STRIKE WITH A TWIST
class QuickAttack extends PhysicalMove with SingleStrike {
  override val index = 98
  override val type1 = Normal
  override val power = 40
  override val maxPP = 30
  override val priority = 1
}

class Slash extends PhysicalMove with SingleStrike {
  override val index = 163
  override val type1 = Normal
  override val power = 70
  override val maxPP = 20
  override val critHitRate = HIGH
}

class Crabhammer extends PhysicalMove with SingleStrike {
  override val index = 152
  override val type1 = Water
  override val power = 100
  override val maxPP = 10
  override val critHitRate = HIGH
  override val accuracy = 0.9
}


/* PHYSICAL, WITH RECOIL */
abstract class PhysicalSingleStrikeRecoil extends PhysicalMove {
  // TODO: If the user of MOVE attacks first and makes itself faint due to recoil damage, the target will not attack or be subjected to recurrent damage during that round.
  // TODO: Self-inflicted recoil damage from MOVE from the previous turn can be countered if the target does not make a move on the following turn.
  // TODO: If MOVE breaks a substitute, the user will take no recoil damage.
  val recoilProportion : Double
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
      if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
      val recoilDamage = (damageDealt * recoilProportion).toInt
      attacker.takeDamage(recoilDamage)
      if (VERBOSE) println(s"${attacker.name} took $recoilDamage recoil damage")
    }
  }
}

class Submission extends PhysicalMove with SingleStrikeRecoil {
  override val index = 66
  override val type1 = Fighting
  override val power = 80
  override val maxPP = 25
  override val accuracy = 0.80
  override val recoilProportion = 0.25
}

class DoubleEdge extends PhysicalMove with SingleStrikeRecoil {
  override val index = 38
  override val type1 = Normal
  override val power = 100  // higher in later generations
  override val maxPP = 15
  override val recoilProportion = 0.25
}

class TakeDown extends PhysicalMove with SingleStrikeRecoil {
  override val index = 36
  override val type1 = Normal
  override val power = 90
  override val maxPP = 20
  override val accuracy = 0.85
  override val recoilProportion = 0.25
}

class Struggle extends PhysicalMove with SingleStrikeRecoil {
  override val index = 165
  override val type1 = Normal
  override val power = 50
  override val maxPP = 1
  var currentPP = 1
  override val recoilProportion = 0.5   // different from others!

  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Don't deduct a PP! Just log it
    pb.moveManager.updateLastMoveIndex(attacker, index)
  }
}


/* PHYSICAL: SINGLE STRIKE, POTENTIAL STAT CHANGE */


/* PHYSICAL: MULTI STRIKE */

class PinMissile extends PhysicalMultiStrike {
  override val index = 42
  override val type1 = Bug
  override val power = 14
  override val maxPP = 20
  override val accuracy = 0.85
}

class Barrage extends PhysicalMultiStrike {
  override val index = 140
  override val type1 = Normal
  override val power = 15
  override val maxPP = 20
  override val accuracy = 0.85
}

class CometPunch extends PhysicalMultiStrike {
  override val index = 4
  override val type1 = Normal
  override val power = 18
  override val maxPP = 20
  override val accuracy = 0.85
}

class DoubleSlap extends PhysicalMultiStrike {
  override val index = 3
  override val type1 = Normal
  override val power = 15
  override val maxPP = 10
  override val accuracy = 0.85
}

class FuryAttack extends PhysicalMultiStrike {
  override val index = 31
  override val type1 = Normal
  override val power = 15
  override val maxPP = 20
  override val accuracy = 0.85
}

class FurySwipes extends PhysicalMultiStrike {
  override val index = 154
  override val type1 = Normal
  override val power = 18
  override val maxPP = 15
  override val accuracy = 0.80
}

class SpikeCannon extends PhysicalMultiStrike {
  override val index = 131
  override val type1 = Normal
  override val power = 20
  override val maxPP = 15
  // 100% accuracy
}


/* PHYSICAL, DOUBLE STRIKE */
abstract class PhysicalDoubleStrike extends PhysicalMove {
  // TODO: Ends if opponent faints or substitute breaks; see PhysicalMultiStrike
  // TODO: Make sure that Bide and Counter only acknowledge the last attack in this sequence; see PhysicalMultiStrike
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val numStrikes = 2
      val (damageEachTime, critHit) = pb.dc.calc(attacker, defender, this, pb)  // takes crit hits into account
      for (_ <- 1 to numStrikes) {
        defender.takeDamage(damageEachTime)
      }
      if (VERBOSE) println(s"$this hit ${defender.name} $numStrikes times!")
      critHit
    } else false
  }
}

class DoubleKick extends PhysicalDoubleStrike {
  override val index = 24
  override val type1 = Fighting
  override val power = 30
  override val maxPP = 30
}

class Bonemerang extends PhysicalDoubleStrike {
  override val index = 155
  override val type1 = Ground
  override val power = 50
  override val maxPP = 10
}


/* PHYSICAL, FUNCTION OF ENVIRONMENT */
class SeismicToss extends SpecialMove {
  override val index = 69
  override val type1 = Fighting
  override val power = 0
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      defender.takeDamage(attacker.level)
    }
  }
}

class SuperFang extends SpecialMove {
  override val index = 162
  override val type1 = Normal
  override val power = 0
  override val maxPP = 10
  override val accuracy = 0.90

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val damageDealt = (defender.currentHP / 2).max(1)
      defender.takeDamage(damageDealt)
    }
  }
}


/* PHYSICAL, ONE-HIT KO */
abstract class PhysicalOneHitKO extends PhysicalMove {
  // TODO: MOVE will break a Substitute if it hits
  // TODO: MOVE can be countered for infinite damage on the turn it breaks a Substitute.
  override val accuracy = 0.30
  override override val power = 0
  override val maxPP = 5

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb) &&
        pb.statManager.getEffectiveSpeed(attacker) >= pb.statManager.getEffectiveSpeed(defender)) {
      defender.takeDamage(defender.currentHP)
    }
  }
}

class Fissure extends PhysicalOneHitKO {
  override val index = 90
  override val type1 = Ground
}

class Guillotine extends PhysicalOneHitKO {
  override val index = 12
  override val type1 = Normal
}

class HornDrill extends PhysicalOneHitKO {
  override val index = 32
  override val type1 = Normal
}


/* SPECIAL MOVES */
// SPECIAL, DEAL FIXED AMOUNT OF DAMAGE
abstract class SpecialConstantDamage extends SpecialMove {
  override override val power = 0
  val constantDamageAmount : Int

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      defender.takeDamage(constantDamageAmount)
    }
  }
}


class SonicBoom extends SpecialConstantDamage {
  override val index = 49
  override val type1 = Normal
  override val maxPP = 20
  override val accuracy = 0.9
  override val constantDamageAmount = 20
}


// SPECIAL, FUNCTION OF LEVEL
class NightShade extends SpecialMove {
  override val index = 101
  override val type1 = Ghost
  override val power = 0
  override val maxPP = 15
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      defender.takeDamage(attacker.level)
    }
  }
}

class Psywave extends SpecialMove {
  override val index = 149
  override val type1 = Psychic
  override val power = 0
  override val maxPP = 15
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val damageDealt = ((Random.nextDouble + 0.5) * attacker.level).toInt
      defender.takeDamage(damageDealt)
    }
  }
}


// SPECIAL, SINGLESTRIKE WITH POTENTIAL WEIRD STUFF
abstract class SpecialSingleStrike extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
    }
  }
}

class TriAttack extends SpecialSingleStrike {
  // TODO: Why is this listed as a Special move, given that it's type Normal?
  override val index = 161
  override val type1 = Normal
  override val power = 80
  override val maxPP = 10
}

class HydroPump extends SpecialSingleStrike {
  override val index = 56
  override val type1 = Water
  override val power = 120   // down to 110 in Gen IV
  override val maxPP = 5
  override val accuracy = 0.8
}

class Surf extends SpecialSingleStrike {
  override val index = 57
  override val type1 = Water
  override val power = 95   // down to 90 in Gen IV
  override val maxPP = 15
}

class WaterGun extends SpecialSingleStrike {
  override val index = 55
  override val type1 = Water
  override val power = 40
  override val maxPP = 25
}

class RazorLeaf extends SpecialSingleStrike {
  override val index = 75
  override val type1 = Grass
  override val power = 55
  override val maxPP = 25
  override val accuracy = 0.95
  override val critHitRate = HIGH
}


// TODO: SWIFT: IGNORE MODS TO ACCURACY AND EVASION, HIT FLY/DIG POKEMON


// SPECIAL: TRANSFER HP
abstract class SpecialTransferHP extends SpecialMove {
  // TODO: If MOVE breaks a substitute, no HP will be restored to the user.
  val transferProportion = 0.5
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
      val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
      defender.takeDamage(damageDealt)
      damageDealt match {
        case 1 => attacker.gainHP(1)
        case _ => attacker.gainHP((damageDealt * transferProportion).toInt)
      }
    }
  }
}

class Absorb extends SpecialTransferHP {
  override val index = 71
  override val type1 = Grass
  override val power = 20
  override val maxPP = 20  // 25 in later gens
}

class MegaDrain extends SpecialTransferHP {
  override val index = 72
  override val type1 = Grass
  override val power = 40
  override val maxPP = 10  // 15 in later gens
}

class DreamEater extends SpecialMove {
  // TODO: If DreamEater breaks a substitute, no HP will be restored to the user.
  override val index = 138
  override val type1 = Psychic
  override val power = 40
  override val maxPP = 10  // 15 in later gens

  val transferProportion = 0.5

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    defender.statusAilment match {
      case Some(_ : SLP) => {
        if (Random.nextDouble < chanceHit(attacker, defender, pb)) {
          val (damageDealt, critHit) = pb.dc.calc(attacker, defender, this, pb)
          defender.takeDamage(damageDealt)
          damageDealt match {
            case 1 => attacker.gainHP(1)
            case _ => attacker.gainHP((damageDealt * transferProportion).toInt)
          }
        }
      }
      case _ => {}
    }
  }
}


// SPECIAL, DAMAGE + POTENTIAL STAT CHANGE
abstract class SpecialDamageStat extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: fill in!
  }
}


// SPECIAL, DAMAGE + POTENTIAL STATUS CHANGE
abstract class SpecialDamageStatus extends SpecialMove {
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: fill in!
  }
}


abstract class Thunderbolt extends SpecialDamageStatus
abstract class ThunderShock extends SpecialDamageStatus
abstract class Ember extends SpecialDamageStatus


/* STATUS MOVES */
abstract class StatusChangeAttackerStats extends StatusMove {
  val statToChange : BattleStat.Value
  val amount : Int
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (pb.statManager.canChangeOwnStats(attacker, pb)) {
	  statToChange match {
	    case ATTACK   => pb.statManager.changeAttackStage(attacker, amount)
	    case DEFENSE  => pb.statManager.changeDefenseStage(attacker, amount)
	    case SPEED    => pb.statManager.changeSpeedStage(attacker, amount)
	    case SPECIAL  => pb.statManager.changeSpecialStage(attacker, amount)
	    case ACCURACY => pb.statManager.changeAccuracyStage(attacker, amount)
	    case EVASION  => pb.statManager.changeEvasionStage(attacker, amount)
	  }
    }
  }
}

class Sharpen extends StatusChangeAttackerStats {
  override val index = 159
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = ATTACK
  override val amount = 1
}

class Meditate extends StatusChangeAttackerStats {
  override val index = 96
  override val type1 = Psychic
  override val maxPP = 40
  override val statToChange = ATTACK
  override val amount = 1
}

class SwordsDance extends StatusChangeAttackerStats {
  override val index = 14
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = ATTACK
  override val amount = 2
}


class DefenseCurl extends StatusChangeAttackerStats {
  override val index = 111
  override val type1 = Normal
  override val maxPP = 40
  override val statToChange = DEFENSE
  override val amount = 1
}

class Withdraw extends StatusChangeAttackerStats {
  override val index = 110
  override val type1 = Water
  override val maxPP = 40
  override val statToChange = DEFENSE
  override val amount = 1
}

class Harden extends StatusChangeAttackerStats {
  override val index = 106
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = 1
}


class AcidArmor extends StatusChangeAttackerStats {
  override val index = 151
  override val type1 = Poison
  override val maxPP = 40
  override val statToChange = DEFENSE
  override val amount = 2
}


class Barrier extends StatusChangeAttackerStats {
  override val index = 112
  override val type1 = Psychic
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = 2
}


class DoubleTeam extends StatusChangeAttackerStats {
  override val index = 104
  override val type1 = Normal
  override val maxPP = 15
  override val statToChange = EVASION
  override val amount = 1
}

class Minimize extends StatusChangeAttackerStats {
  override val index = 107
  override val type1 = Normal
  override val maxPP = 20
  override val statToChange = EVASION
  override val amount = 1
}

class Agility extends StatusChangeAttackerStats {
  override val index = 97
  override val type1 = Psychic
  override val maxPP = 30
  override val statToChange = SPEED
  override val amount = 2
}

class Growth extends StatusChangeAttackerStats {
  override val index = 74
  override val type1 = Normal
  override val maxPP = 40
  override val statToChange = SPECIAL
  override val amount = 1
}

class Amnesia extends StatusChangeAttackerStats {
  override val index = 133
  override val type1 = Psychic
  override val maxPP = 20
  override val statToChange = SPECIAL
  override val amount = 2
}


// STATUSMOVES that change the opponent's stats
// TODO: Make sure that the opponent's stats can actually be changed!
abstract class StatusChangeDefenderStats extends StatusMove {
  val statToChange : BattleStat.Value
  val amount : Int
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (pb.statManager.canChangeDefenderStats(attacker, defender, pb)) {
      statToChange match {
        case ATTACK   => pb.statManager.changeAttackStage(defender, amount)
        case DEFENSE  => pb.statManager.changeDefenseStage(defender, amount)
        case SPEED    => pb.statManager.changeSpeedStage(defender, amount)
        case SPECIAL  => pb.statManager.changeSpecialStage(defender, amount)
        case ACCURACY => pb.statManager.changeAccuracyStage(defender, amount)
        case EVASION  => pb.statManager.changeEvasionStage(defender, amount)
      }
    }
  }
}

class StringShot extends StatusChangeDefenderStats {
  override val index = 81
  override val accuracy = .95          // in [0.0, 1.0]
  override val type1 = Bug
  override val maxPP = 40
  override val statToChange = SPEED
  override val amount = -1
}

class SandAttack extends StatusChangeDefenderStats {
  override val index = 28
  override val type1 = Normal  // changed in later Gens
  override val maxPP = 15
  override val statToChange = ACCURACY
  override val amount = -1
}

class Flash extends StatusChangeDefenderStats {
  override val index = 148
  override val type1 = Normal
  override val maxPP = 20
  override val accuracy = 0.7
  override val statToChange = ACCURACY
  override val amount = -1
}

class SmokeScreen extends StatusChangeDefenderStats {
  override val index = 108
  override val type1 = Normal
  override val maxPP = 20
  override val statToChange = ACCURACY
  override val amount = -1
}

class Kinesis extends StatusChangeDefenderStats {
  override val index = 134
  override val type1 = Psychic
  override val maxPP = 15
  override val accuracy = 0.8
  override val statToChange = ACCURACY
  override val amount = -1
}

class Growl extends StatusChangeDefenderStats {
  override val index = 45
  override val type1 = Normal
  override val maxPP = 40
  override val statToChange = ATTACK
  override val amount = -1
}

class Leer extends StatusChangeDefenderStats {
  override val index = 43
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = -1
}

class TailWhip extends StatusChangeDefenderStats {
  override val index = 39
  override val type1 = Normal
  override val maxPP = 30
  override val statToChange = DEFENSE
  override val amount = -1
}

class Screech extends StatusChangeDefenderStats {
  override val index = 103
  override val type1 = Normal
  override val maxPP = 40
  override val accuracy = 0.85
  override val statToChange = DEFENSE
  override val amount = -2
}


// STATUSMOVES that change the opponent's statusAilment
abstract class StatusCauseStatusAilment extends StatusMove {
  val statusAilmentToCause : StatusAilment
  val chanceOfCausingAilment : Double

  def statusAilmentCaused : Boolean = Random.nextDouble < chanceOfCausingAilment

  // TODO: Figure out if there are times when a Pokemon is immune to StatusAilment changes, and incorporate them
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    if (Random.nextDouble < chanceHit(attacker, defender, pb) && statusAilmentCaused) {
      statusAilmentToCause match {
        case (_ : NonVolatileStatusAilment) => pb.statusManager.tryToChangeStatusAilment(defender, statusAilmentToCause)
        case (_ : CONFUSION) => pb.statusManager.tryToCauseConfusion(defender)
        case (_ : FLINCH) => pb.statusManager.causeToFlinch(defender)
        case (_ : PARTIALLYTRAPPED) => { pb.statusManager.tryToPartiallyTrap(defender) }
        case (_ : SEEDED) => pb.statusManager.tryToSeed(defender)
      }
    }
  }
}

class ThunderWave extends StatusCauseStatusAilment {
  override val index = 86
  override val type1 = Electric
  override val maxPP = 20
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
}

class StunSpore extends StatusCauseStatusAilment {
  override val index = 78
  override val type1 = Grass
  override val maxPP = 30
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75
}

class Glare extends StatusCauseStatusAilment {
  override val index = 137
  override val type1 = Normal
  override val maxPP = 30
  val statusAilmentToCause = new PAR
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75  // increased in later generations
}

class ConfuseRay extends StatusCauseStatusAilment {
  override val index = 109
  override val type1 = Ghost
  override val maxPP = 10
  val statusAilmentToCause = new CONFUSION
  val chanceOfCausingAilment = 1.0
  // TODO: ConfuseRay will fail if the target has a substitute
}

class Supersonic extends StatusCauseStatusAilment {
  override val index = 48
  override val type1 = Normal
  override val maxPP = 20
  val statusAilmentToCause = new CONFUSION
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.55
  // TODO: Supersonic will fail if the target has a substitute
}

class SleepPowder extends StatusCauseStatusAilment {
  override val index = 79
  override val type1 = Grass
  override val maxPP = 15
  val statusAilmentToCause = new SLP
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.75
  // TODO: SleepPowder will fail if the target has a substitute
}

class Hypnosis extends StatusCauseStatusAilment {
  override val index = 95
  override val type1 = Psychic
  override val maxPP = 15
  val statusAilmentToCause = new SLP
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.60
}

class PoisonGas extends StatusCauseStatusAilment {
  override val index = 139
  override val type1 = Poison
  override val maxPP = 40
  val statusAilmentToCause = new PSN
  val chanceOfCausingAilment = 1.0
  override val accuracy = 0.55
}

class Toxic extends StatusMove {
  override val index = 92
  override val type1 = Poison
  override val maxPP = 10
  val chancePSN = 1.0
  override val accuracy = 0.85


  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: Toxic is a mess and almost surely requires a battle data structure
  }
}


/* SUPER WEIRD STATUS MOVES */
class MirrorMove extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Get the last move that $defender used during his current stay in battle;
    val lastMove : Option[Move] = pb.moveManager.getLastMove(defender)

    // $attacker should use lastMove against $defender
    lastMove match {
      case Some(m) => m.use(attacker, defender, pb)
      case None    => {}
    }
  }

  /* MirrorMove would get the updateLastMoveIndex wrong, since the order would be:
   * MirrorMove.startUsingMove()
   * MirrorMove.moveSpecificStuff()   => uses Move m
   *   m.startUsingMove()
   *   m.moveSpecificStuff()
   *   m.finishUsingMove()            => sets lastMoveUsed to the correct value
   * Move.finishUsingMove()     => sets it back to incorrect value
   * So just don't update lastMoveUsed after calling MirrorMove!
   */
  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    currentPP -= 1
  }
}

class Haze extends StatusMove {
  override val index = 114
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) {
    // http://bulbapedia.bulbagarden.net/wiki/Haze_(move)
    // reset the stat levels of both active Pokemon to 0
    pb.statManager.resetAll(attacker)
    pb.statManager.resetAll(defender)

    // TODO: fill in all the crazy stuff that Haze does
    // remove the stat reductions due to BRN/PAR

    // negate Focus Energy for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate Light Screen for both active Pokemon

    // negate Mist for both active Pokemon

    // negate Reflect for both active Pokemon

    // negate confusion for both active Pokemon

    // negate Leech Seed for both active Pokemon

    // negate any major status ailments for THE ENEMY

    // Superweird thing that happens if an opponent is trying to use Hyper Beam, then gets frozen, and then Haze unfreezes him
  }
}

class Mist extends StatusMove {
  override val index = 54
  override val type1 = Ice
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Mist_(move)
    // Mist protects the user from stat mods inflicted by the opponent until it switches out
    // TODO: flip the Mist switch for attacker in the Battle's Mist data structure
  }
}

class Conversion extends StatusMove {
  override val index = 160
  override val type1 = Normal
  override val maxPP = 30

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Conversion changes the types of the attacker to be those of the defender
    // Porygon is the only Pokemon in the game that can learn this move
    assert(attacker.index == 137, "someone other than Porygon tried to use Conversion!")
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2
  }
}

class Metronome extends StatusMove {
  override val index = 119
  override val type1 = Flying
  override val maxPP = 20

  private def getValidIndex() : Int = {
      val potentialIndex = Utils.intBetween(1, 165 + 1)
      if (potentialIndex != index && potentialIndex != 165) potentialIndex
      else getValidIndex()
  }

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // randomly selects a move (other than itself and Struggle) and then executes the attack with normal priority
    val randomIndex = getValidIndex()
    val moveToUse = MoveMaker.makeMove(randomIndex)
    // moveToUse.priority = 0    // TODO: make this work!
    moveToUse.use(attacker, defender, pb)
  }

  override def finishUsingMove(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // The random move used is logged as the most recent move used, so don't log a la MirrorMove
    currentPP -= 1
  }
}

class Mimic extends StatusMove {
  override val index = 102
  override val type1 = Normal
  override val maxPP = 20

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // TODO: figure out what Mimic actually does in Gen 1, then make it happen
  }
}

class Recovery extends StatusMove {
  override val index = 105
  override val type1 = Normal
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.recoverBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Rest extends StatusMove {
  override val index = 156
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Rest_(move)
    // On the turn that the Pokemon uses it: switch to SLP, regain all HP
    // Next turn: Pokemon is asleep, can Switch; choosing Fight causes it to tell you that Pokemon is asleep
    // Next turn: wake up at beginning of turn, can use an action
    // TODO: implement this in some data structure that tracks SLP
  }
}

class SoftBoiled extends StatusMove {
  override val index = 135
  override val type1 = Psychic
  override val maxPP = 10

  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // Same as recovery!
    val currentHP = attacker.currentHP
    val maxHP = attacker.maxHP
    if (currentHP > maxHP) {
      attacker.currentHP = maxHP
    } else if (currentHP == maxHP) {
      // no recovering necessary
    } else if (Battle.softboiledBugEnabled && ((maxHP - currentHP) + 1) % 256 == 0) {
      // bug - do nothing!
    } else {
      val hpToHeal = maxHP / 2
      attacker.gainHP(hpToHeal)
    }
  }
}

class Roar extends StatusMove {
  override val index = 46
  override val type1 = Normal
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Whirlwind extends StatusMove {
  override val index = 18
  override val type1 = Normal
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Teleport extends StatusMove {
  override val index = 100
  override val type1 = Psychic
  override val maxPP = 20
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against another trainer
  }
}

class Splash extends StatusMove {
  override val index = 150
  override val type1 = Normal
  override val maxPP = 40
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // no effect in Gen 1 against anyone
  }
}

class Transform extends StatusMove {
  override val index = 144
  override val type1 = Normal
  override val maxPP = 10
  override def moveSpecificStuff(attacker: Pokemon, defender: Pokemon, pb: Battle) = {
    // http://bulbapedia.bulbagarden.net/wiki/Transform_(move)
    // http://www.smogon.com/rb/moves/Transform

    // Change the user's current type to that of the target
    attacker.type1 = defender.type1
    attacker.type2 = defender.type2

    // Change the user's current stats to that of the target
    // TODO: which stats, exactly, are duplicated? EV? IV? attack/defense?

    // Change the user's current stat modifications to that of the target
    pb.statManager.setAttackStage(attacker, pb.statManager.attackStages(defender))
    pb.statManager.setDefenseStage(attacker, pb.statManager.defenseStages(defender))
    pb.statManager.setSpecialStage(attacker, pb.statManager.specialStages(defender))
    pb.statManager.setSpeedStage(attacker, pb.statManager.speedStages(defender))
    pb.statManager.setAccuracyStage(attacker, pb.statManager.accuracyStages(defender))
    pb.statManager.setEvasionStage(attacker, pb.statManager.evasionStages(defender))

    // Change the user's current moves to those of the target
    val move1 = defender.move1 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move2 = defender.move2 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move3 = defender.move3 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
    val move4 = defender.move4 match {
      case None => None
      case Some(m) => {
        val newMove = MoveMaker.makeMove(m.index)
        newMove.maxPP = 5
        newMove.currentPP = 5
        newMove
      }
    }
  }
}
